Система расчета урона для RPG

Контекст: Вы работаете в команде над инди-ролевой игрой. 
  Вам поручили разработать ядро системы расчета урона. 
  Дизайнеры хотят, чтобы урон мог рассчитываться множеством разных способов 
  в зависимости от ситуации, но через единый, понятный интерфейс.

Задача: 
  Создать статический класс DamageCalculator с перегруженными версиями метода CalculateDamage. 
  Каждая версия будет учитывать разные игровые механики.

Требования к реализации:
1. Базовый расчет (Обязательная перегрузка №1):
   - Метод: CalculateDamage(int baseDamage, float attackerAttackStat, float defenderDefenseStat)
   - Формула: Урон = baseDamage * (attackerAttackStat / defenderDefenseStat)
   - Описание: Стандартная формула для физической атаки.

2. Расчет с критическим ударом и шансом (Перегрузка №2):
   - Метод: CalculateDamage(int baseDamage, float attackerAttackStat, float defenderDefenseStat, float criticalMultiplier, float criticalChance)
   - Логика:
      1. Сначала рассчитывается базовый урон по формуле из п.1.
      2. Генерируется случайное число от 0 до 1 (используйте Random).
      3. Если это число меньше или равно criticalChance, то итоговый урон умножается на criticalMultiplier.
   - Описание: Моделирует атаку с шансом на крит.

3. Расчет с учетом стихийного сопротивления (Перегрузка №3):
   - Метод: CalculateDamage(int baseDamage, float attackerAttackStat, float defenderDefenseStat, string damageType, Dictionary<string, float> defenderResistances)
   - Логика:
      1. Рассчитывается базовый урон.
      2. В словаре defenderResistances ищется значение сопротивления (resistance) по ключу damageType (например, "Fire", "Frost", "Poison").
      3. Если ключ найден, урон умножается на (1 - resistance). (Например, сопротивление 0.3 уменьшит урон на 30%).
      4. Урон не может быть отрицательным.
   - Описание: Для магических и стихийных атак.

4. Расчет "по площади" (AoE) с затуханием (Перегрузка №4):
   - Метод: CalculateDamage(int baseDamage, float attackerAttackStat, float defenderDefenseStat, double distanceFromEpicenter, double maxRadius)
   - Логика:
      1. Если distanceFromEpicenter > maxRadius, урон равен 0.
      2. Иначе рассчитывается базовый урон.
      3. Применяется линейное затухание: итоговый урон умножается на (1 - distanceFromEpicenter / maxRadius).
   - Описание: Для взрывов, заклинаний площади. Симулирует, что чем дальше цель от центра взрыва, тем слабее урон.

Дополнительные цели

- Инкапсуляция/Проверка: 
   Внутри методов добавьте проверки входных данных 
   (чтобы defenderDefenseStat не был равен нулю, criticalChance был в диапазоне [0,1] и т.д.). 
   Используйте if и выброс исключений или возврат 0.

- Работа с консолью (для демонстрации): 
   Создайте метод static void Test() внутри класса DamageCalculator. Внутри этого метода:
     - Создайте тестового защитника со словарем сопротивлений { {"Fire", 0.5f}, {"Frost", 0.2f} }.
     - Продемонстрируйте работу ВСЕХ четырех перегрузок, 
       выводя в консоль осмысленные описания атак и рассчитанный урон.
     - Используйте String Interpolation для красивого форматирования вывода.

- Использование коллекций: Вы уже используете Dictionary в 3-й перегрузке.

- Логические операторы: Они понадобятся в проверках условий 
   (например, if (criticalChance < 0 || criticalChance > 1)).


Пример вывода в консоль из метода Test():

=== Тест системы урона ===
1. Мечом по голему: 150 урона.
2. Выстрел с шансом крита (75%)... КРИТИЧЕСКИЙ УДАР! 450 урона!
3. Огненный шар по ледяному элементалю (сопр. 50%): 120 урона.
4. Взрыв гранаты (цель в 2м из 5м): 90 урона.


Совет: Начните с создания пустых методов с разными сигнатурами, затем заполняйте логику по одной. Сначала реализуйте расчет, потом добавьте проверки и в конце — демонстрацию.