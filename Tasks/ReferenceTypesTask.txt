Техническое задание: "Система инвентаря и модификации предметов"

Контекст:
	Вы — разработчик в небольшой инди-студии, работающей над roguelike-игрой. 
	Вам поручили реализовать прототип системы, которая управляет набором "магических камней",
	усиливающих оружие игрока. Камни нужно применять, комбинировать и
	передавать между разными "слотами" инвентаря.

Постановка задачи (как от продюсера)
	"Нам нужен прототип, который наглядно покажет, 
	как работают ссылки в памяти при манипуляциях с предметами инвентаря. 
	Игрок находит камни, они лежат в "сумке". Он может вставить камень в "сокет" оружия. 
	При этом камень физически переходит из сумки в сокет (а не копируется). 
	Если потом вынуть камень из оружия, он должен вернуться обратно в сумку, в тот же "слот памяти". 
	Также нужно сделать функцию "объединения" двух камней из сумки в один более мощный, 
	с проверками и последствиями для ссылок.

	Это основа для будущей сложной системы крафта. 
	Прототип должен быть консольным, но максимально наглядно демонстрировать 
	все операции и изменения в данных."

Требования к реализации:
1. Класс MagicStone (Магический камень):
   - Поля: Name (название), Power (сила усиления, целое число), Id (уникальный идентификатор).
   - Конструктор для инициализации.
   - Метод PrintInfo(), выводящий информацию о камне в консоль.

2. Логика работы (основная программа Program.cs):
   - Ссылочные типы в массивах: 
     Создайте два массива MagicStone[]: bag (сумка, размер 5) и weaponSockets (сокеты оружия, размер 2). 
     Изначально они заполнены null.
   - Инициализация: 
     С помощью Random создайте 3 случайных камня и поместите их в случайные свободные ячейки bag.
   - Цикл и интерфейс: Реализуйте консольное меню с действиями:
     - 1. Показать состояние сумки и сокетов.
     - 2. Переместить камень из сумки в сокет (пользователь вводит индексы).
     - 3. Вынуть камень из сокета обратно в сумку (ввести индекс сокета и целевой индекс сумки).
     - 4. Объединить два камня из сумки (ввести индексы двух камней). 
          Суть задания: При объединении создается новый камень с суммарной силой, 
          который помещается на место первого выбранного камня. 
          Ссылка на второй камень должна быть обнулена (null), 
          а сам объект второго камня в будущем будет удален сборщиком мусора. 
          Это нужно наглядно показать в выводе.
     - 5. Выход.
3. Ключевые проверки (используйте if, else):
   - Нельзя переместить null.
   - Нельзя переместить камень в занятый сокет/ячейку.
   - При объединении проверять, что оба индекса указывают на реальные камни (!= null).

 Ожидаемое поведение (пример работы в консоли)

=== Магическая кузница (прототип) ===

Действие 1 - Показать состояние:
Сумка:       [Камень Огня(Pwr:10)] | [Камень Воды(Pwr:7)] | [null] | [null] | [null]
Сокеты оружия: [null] | [null]

Действие 2 - Переносим камень из bag[0] в socket[0].
Действие 1 - Показать состояние:
Сумка:       [null] | [Камень Воды(Pwr:7)] | [null] | [null] | [null]
Сокеты оружия: [Камень Огня(Pwr:10)] | [null]
// Обрати внимание: объект КАМНЯ ОГНЯ один в памяти. Теперь на него ссылается socket[0], а bag[0] стал null.

Действие 4 - Объединить камень bag[1] (Воды) и bag[0] (null?).
> Ошибка: Второй выбранный слот пуст!
Действие 3 - Вернем камень из socket[0] в bag[0].
Действие 4 - Объединить камень bag[1] (Воды) и bag[0] (Огня).
Создан новый камень: [Камень Стихий(Pwr:17)] на месте bag[1].
Камень в слоте bag[0] уничтожен (ссылка обнулена).

Действие 1 - Показать состояние:
Сумка:       [null] | [Камень Стихий(Pwr:17)] | [null] | [null] | [null]
Сокеты оружия: [null] | [null]