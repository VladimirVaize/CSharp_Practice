Легенда (Вводная)

Студия выпустила игру про подземелья. В коде есть классы Hero (Герой) и Mob (Монстр). 
Игроки жалуются на вылеты игры, а отдел маркетинга требует добавить в игру нового союзника — "Боевого пса".

Задание: Рефакторинг и реализация "Боевого пса"

Часть 1. Баг-фикс

В отделе тестирования нашли проблему.
В коде есть метод, который лечит союзников, 
но по ошибке может вылечить и монстра (что не по задумке), 
или метод нанесения урона может нанести урон самому герою.

Тебе дан упрощенный код. Нужно его исправить, используя знания о проверке типов (is, as), чтобы:
1. Метод Heal лечил только героев (класс Hero и будущих союзников).
2. Метод TakeDamage не позволял герою атаковать самого себя.

public abstract class Entity
{
    public string Name { get; set; }
    public int Health { get; set; }
    public int MaxHealth { get; set; }

    protected Entity(string name, int health)
    {
        Name = name;
        Health = health;
        MaxHealth = health;
    }

    public virtual void TakeDamage(int damage)
    {
        Health -= damage;
        Console.WriteLine($"{Name} получил {damage} урона. Осталось здоровья: {Health}");
    }
}

public class Hero : Entity
{
    public Hero(string name, int health) : base(name, health) { }
}

public class Mob : Entity
{
    public Mob(string name, int health) : base(name, health) { }
}

public class GameEngine
{
    // МЕТОД, КОТОРЫЙ НУЖНО ИСПРАВИТЬ (Часть 1)
    // Задача: Лечить можно только Героев (Hero). На вход может прийти кто угодно (Mob, Hero).
    public void Heal(Entity target, int amount)
    {
        // БАГ: Сейчас метод лечит всех подряд.
        // НУЖНО: С помощью "is" или "as" проверить, является ли target героем.
        // Если это не герой - выводим сообщение "Нельзя вылечить монстра!" и выходим из метода.
        target.Health += amount;
        if (target.Health > target.MaxHealth) target.Health = target.MaxHealth;
        Console.WriteLine($"{target.Name} вылечен на {amount}. Текущее здоровье: {target.Health}");
    }

    // МЕТОД, КОТОРЫЙ НУЖНО ИСПРАВИТЬ (Часть 2)
    // Задача: Герой не может атаковать сам себя.
    public void HeroAttackEntity(Hero attacker, Entity target, int damage)
    {
        // БАГ: Сейчас герой может ударить сам себя.
        // НУЖНО: Если attacker и target - это один и тот же объект (ссылаются на один участок памяти),
        // вывести сообщение "Нельзя атаковать себя!" и не наносить урон.
        
        // Подсказка: сравнение ссылочных типов.
        
        target.TakeDamage(damage);
    }
}

Твоя задача: 
   Раскомментировать код в методах Heal и HeroAttackHero, 
   дописав условия проверок, чтобы код работал по правилам.


Часть 2. Новая фича (Отношения Is-A и Has-A)

Геймдизайнер придумал нового союзника — "Боевой пес" (WarDog). 
Пес — это не просто монстр, а друг героя.
Теперь нужно спроектировать класс WarDog, 
используя отношения Is-A (является кем-то) и Has-A (имеет что-то).

Вводные от геймдизайнера:
1. Пес должен уметь кусать врагов (монстров). Укус наносит урон.
2. Пес не должен убегать с поля боя. У него есть хозяин (герой), которому он верен.
3. Если хозяин погибает (Health <= 0), пес впадает в ярость и получает временный бонус к урону (+5 к атаке).
4. Пес не может атаковать других героев или своего хозяина.

Технические требования:
1. Is-A: Пес должен быть кем? Hero или Entity? 
   Исходя из условия "не атакует героев", логично, чтобы система распознавала его как союзника. 
   Значит, он должен наследоваться от класса Hero. 
   Следовательно, отношение: WarDog IS-A Hero.

2. Has-A: У пса есть хозяин. Это поле должно хранить ссылку на объект Hero. 
   Отношение: WarDog HAS-A Hero (композиция/агрегация).

3. Конструктор должен принимать имя пса, его здоровье и ссылку на объект хозяина (героя).

4. Переопределить метод TakeDamage (если нужно, по желанию, например, чтобы пес рычал при получении урона).

5. Создать метод Bite(Mob target), 
   который реализует атаку по монстру с проверкой: если хозяин мертв, урон увеличивается.

Допиши класс Program, чтобы протестировать пса:
1. Создай героя.
2. Создай пса, передай ему этого героя.
3. Создай монстра.
4. Пусть пес укусит монстра (обычная ситуация).
5. Убей героя (установи его Health = 0).
6. Пусть пес снова укусит монстра (проверь, увеличился ли урон).


Пример вывода:

Задание: 1
=======================================================

Нельзя вылечить монстра!
Артур вылечен на 10 здоровья. Текущее здоровье 100/100
Нельзя атаковать себя
Гоблин получил 10 урона. Осталось здоровья: 40/50

Артур: 100/100
Гоблин: 40/50

Задание: 2
=======================================================

Пёсель кусает Гоблин
Гоблин получил 15 урона. Осталось здоровья: 25/50
Артур получил 200 урона. Осталось здоровья: 0/100
Артур погиб! Причина: получен смертельный урон.
Пёсель кусает Гоблин
Гоблин получил 20 урона. Осталось здоровья: 5/50

Артур: 0/100
Гоблин: 5/50
Пёсель: 40/40